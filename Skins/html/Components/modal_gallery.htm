<!-- Модальное окно галереи -->
<div
  id="gallery-modal"
  class="fixed inset-0 bg-black bg-opacity-90 z-[999] items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300 hidden"
>
  <!-- Левая панель миниатюр (десктоп) -->
  <div
    id="gallery-thumbnails-desktop"
    class="hidden lg:block absolute left-4 top-4 bottom-4 w-20 flex flex-col items-center py-2 space-y-2 overflow-y-auto overflow-x-hidden z-[60]"
  >
    <!-- Миниатюры будут добавляться динамически -->
  </div>

  <!-- Нижняя панель миниатюр (мобильные) -->
  <div
    id="gallery-thumbnails-mobile"
    class="lg:hidden absolute bottom-4 left-4 right-4 h-20 flex items-center overflow-x-auto overflow-y-hidden py-2 space-x-2 z-[60] scrollbar-none"
  >
    <!-- Миниатюры будут добавляться динамически -->
  </div>

  <!-- Центральное изображение -->
  <div
    id="gallery-image-container"
    class="relative h-full flex items-center justify-center rounded-xl overflow-hidden transition-all duration-300 ease-out lg:ml-24 mb-8 lg:mb-0"
  >
    <img
      id="gallery-main-img"
      src=""
      alt=""
      class="max-w-full max-h-[calc(90vh-2rem)] lg:max-h-[90vh] object-contain shadow-2xl transition-transform duration-300 ease-out cursor-zoom-in"
    />
  </div>

  <!-- Кнопка закрытия -->
  <button
    id="gallery-close"
    class="absolute top-4 right-4 text-white/90 hover:text-white text-lg font-light z-[61] bg-black/40 backdrop-blur-sm rounded-full w-10 h-10 flex items-center justify-center transition-all duration-200 ease-in-out hover:bg-black/60"
    aria-label="Закрыть галерею"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
  </button>

  <!-- Стрелка "назад" -->
  <button
    id="gallery-prev"
    class="absolute lg:left-28 left-4 top-[calc(50%-2.2rem)] -translate-y-1/2 z-[61] p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-sm text-white transition-all duration-200 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-white/40"
    aria-label="Предыдущее изображение"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
    </svg>
  </button>

  <!-- Стрелка "вперёд" -->
  <button
    id="gallery-next"
    class="absolute right-4 top-[calc(50%-2.2rem)] -translate-y-1/2 z-[61] p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-sm text-white transition-all duration-200 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-white/40"
    aria-label="Следующее изображение"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
    </svg>
  </button>

  <!-- Счётчик -->
  <div
    id="gallery-counter"
    class="absolute lg:bottom-4 bottom-28 left-1/2 -translate-x-1/2 text-white/80 text-sm font-mono tracking-wide bg-black/30 px-3 py-1.5 rounded-full backdrop-blur-sm z-[62]"
  ></div>

  <!-- Индикатор масштаба -->
  <div
    id="gallery-zoom-indicator"
    class="absolute top-4 lg:left-28 left-4 text-white/80 text-sm font-mono tracking-wide bg-black/30 px-3 py-1.5 rounded-full backdrop-blur-sm hidden z-[62]"
  >
    100%
  </div>

  <!-- Кнопка сброса зума (только для мобильных) -->
  <button
    id="gallery-reset-zoom"
    class="lg:hidden absolute bottom-24 right-4 text-white/90 text-sm font-light z-[61] bg-black/60 backdrop-blur-sm rounded-full w-10 h-10 flex items-center justify-center transition-all duration-200 ease-in-out hover:bg-black/80 hidden"
    aria-label="Сбросить масштаб"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7" />
    </svg>
  </button>
</div>

<?php
$photosUnified = [];

// --- Если это ФОТО ТОВАРА (присутствует rm) ---
if (isset($photos[0]['rm'])) {

    foreach ($photos as $p) {
        $photosUnified[] = [
            'src'   => Catalog::photoUrl(
Catalog_Series_Photos::$imagePath,
$p['id'], 0, 0, 0, $p['_img_ext'],
[$catInf['url'], $seriesInf['url']]
),
'thumb' => Catalog::photoUrl(
Catalog_Series_Photos::$imagePath,
$p['id'], 90, 90, $p['rm'], $p['_img_ext']
),
'alt'   => hsch(
trim($p['alt'])
? $p['alt']
: $catInf['name'] . ' ' . $seriesInf['name']
),
'highslide' => false
];
}
}

// --- Если это ФОТО ПРОЕКТА ---
else {


foreach ($photos as $i => $p) {

// большие изображения
$src = Config::pathRel('images') .
Clients_Projects_Pics::$imagePath .
$p['id'] . '_0x0_1_wm.' . $p['_img_ext'];

// миниатюры
$thumb = Config::pathRel('images') .
Clients_Projects_Pics::$imagePath .
$p['id'] .
($i === 0 ? '_290x255_0_wm.' : '_197x153_0_wm.') .
$p['_img_ext'];

$photosUnified[] = [
'src'       => $src,
'thumb'     => $thumb,
'alt'       => hsch($p['alt']),
'highslide' => true
];
}
}
?>

<style>
  /* Скрываем скроллбар для всех элементов */
  .scrollbar-none {
    -ms-overflow-style: none;  /* IE и Edge */
    scrollbar-width: none;     /* Firefox */
  }

  .scrollbar-none::-webkit-scrollbar {
    display: none; /* Chrome, Safari и Opera */
  }

  /* Стили для десктопных миниатюр */
  #gallery-thumbnails-desktop {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  #gallery-thumbnails-desktop::-webkit-scrollbar {
    display: none;
  }

  /* Плавный скролл для миниатюр */
  #gallery-thumbnails-desktop,
  #gallery-thumbnails-mobile {
    scroll-behavior: smooth;
  }

  /* Гарантируем целочисленное количество миниатюр */
  #gallery-thumbnails-desktop {
    height: calc(100vh - 8rem); /* Оставляем место для кнопок */
  }

  #gallery-thumbnails-mobile {
    min-height: 5rem; /* Фиксированная высота для мобильных */
  }

  /* Корректное отображение миниатюр */
  #gallery-thumbnails-desktop img,
  #gallery-thumbnails-mobile img {
    aspect-ratio: 1;
    object-fit: cover;
  }

  /* Плавное появление миниатюр */
  #gallery-thumbnails-desktop div,
  #gallery-thumbnails-mobile div {
    transition: transform 0.2s ease, border-color 0.2s ease;
  }

  /* Активная миниатюра */
  #gallery-thumbnails-desktop div.active,
  #gallery-thumbnails-mobile div.active {
    transform: scale(0.95);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // --- Данные галереи (подставляется сервером) ---
    const photos = <?= json_encode($photosUnified, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) ?> || [];

    // --- STATE ---
    let currentGalleryIndex = 0;
    let currentMainIndex = 0;

    // zoom / pan state
    let currentScale = 1;
    let translateX = 0;
    let translateY = 0;
    let isZoomed = false;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let pointerId = null;

    // pinch state
    let pinchStartDistance = 0;
    let pinchStartScale = 1;

    // desktop hover-pan raf throttle
    let rafPending = false;

    // constants
    const MIN_ZOOM = 1.2;
    const MAX_ZOOM = 2.0;
    const ZOOM_STEP = 0.1;
    const MOBILE_AUTO_RESET_DELAY = 3000;

    // --- DOM ---
    const mainImage = document.getElementById('main-product-image');
    const mainImageContainer = document.getElementById('mainImageContainer');
    const galleryModal = document.getElementById('gallery-modal');
    const galleryImg = document.getElementById('gallery-main-img');
    const galleryImageContainer = document.getElementById('gallery-image-container');
    const galleryClose = document.getElementById('gallery-close');
    const galleryPrev = document.getElementById('gallery-prev');
    const galleryNext = document.getElementById('gallery-next');
    const galleryCounter = document.getElementById('gallery-counter');
    const galleryZoomIndicator = document.getElementById('gallery-zoom-indicator');
    const galleryResetZoom = document.getElementById('gallery-reset-zoom');
    const thumbsDesktop = document.getElementById('gallery-thumbnails-desktop');
    const thumbsMobile = document.getElementById('gallery-thumbnails-mobile');

    // auto reset timer
    let autoResetZoomTimer = null;
    let lastInteraction = Date.now();

    // ---------- Utility ----------
    function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }

    function updateInteractionTime() {
      lastInteraction = Date.now();
      if (isTouchDevice() && isZoomed) {
        clearTimeout(autoResetZoomTimer);
        autoResetZoomTimer = setTimeout(() => {
          if (Date.now() - lastInteraction >= MOBILE_AUTO_RESET_DELAY) resetZoom();
        }, MOBILE_AUTO_RESET_DELAY);
      }
    }

    // safe parse gap from computed style
    function readGap(container, isMobile) {
      const cs = getComputedStyle(container);
      // fallback 8
      if (isMobile) {
        // horizontal gap might be margin-right on children; try gap/padding
        const gap = parseInt(cs.columnGap || cs.gap || 8);
        return Number.isFinite(gap) ? gap : 8;
      } else {
        const gap = parseInt(cs.rowGap || cs.gap || 8);
        return Number.isFinite(gap) ? gap : 8;
      }
    }

    // ---------- Thumbnails helpers ----------
    function calculateVisibleThumbnails(container, isMobile = false) {
      if (!container || !container.children.length) return 1;
      const first = container.children[0];
      const gap = readGap(container, isMobile);

      if (isMobile) {
        const full = first.offsetWidth + gap;
        return Math.max(1, Math.floor(container.clientWidth / full));
      } else {
        const full = first.offsetHeight + gap;
        return Math.max(1, Math.floor(container.clientHeight / full));
      }
    }

    function createThumbnailElement(photo, index) {
      const thumbnail = document.createElement('div');
      thumbnail.className = 'relative w-16 h-16 rounded-md overflow-hidden cursor-pointer border-2 transition-all duration-200 flex-shrink-0 hover:border-blue-400 active:scale-95';
      thumbnail.style.borderColor = 'transparent';
      thumbnail.dataset.index = index;

      thumbnail.innerHTML = `
      <img
        src="${photo.thumb}"
        alt="${photo.alt || ''}"
        class="w-full h-full object-cover"
        loading="lazy"
        draggable="false"
      />
      <div class="absolute inset-0 bg-black/30 opacity-0 hover:opacity-100 transition-opacity duration-200"></div>
    `;
      return thumbnail;
    }

    function createThumbnails() {
      if (thumbsDesktop) {
        thumbsDesktop.innerHTML = '';
        photos.forEach((p, i) => {
          const t = createThumbnailElement(p, i);
          t.addEventListener('click', (e) => {
            e.stopPropagation();
            openAt(i);
          });
          thumbsDesktop.appendChild(t);
        });
      }
      if (thumbsMobile) {
        thumbsMobile.innerHTML = '';
        photos.forEach((p, i) => {
          const t = createThumbnailElement(p, i);
          t.addEventListener('click', (e) => {
            e.stopPropagation();
            openAt(i);
            scrollToThumbnailIfNeeded(i, 'mobile');
          });
          thumbsMobile.appendChild(t);
        });
      }

      // small delay to ensure layout done
      requestAnimationFrame(() => {
        updateThumbnailSelection();
        scrollToThumbnailIfNeeded(currentGalleryIndex, window.innerWidth < 1024 ? 'mobile' : 'desktop');
      });
    }

    function updateThumbnailSelection() {
      const apply = (container) => {
        if (!container) return;
        Array.from(container.children).forEach((thumb, idx) => {
          if (idx === currentGalleryIndex) {
            thumb.style.borderColor = '#3b82f6';
            thumb.style.borderWidth = '2px';
            thumb.classList.add('active');
          } else {
            thumb.style.borderColor = 'transparent';
            thumb.style.borderWidth = '2px';
            thumb.classList.remove('active');
          }
        });
      };
      apply(thumbsDesktop);
      apply(thumbsMobile);

      // ensure visible
      if (window.innerWidth < 1024) scrollToThumbnailIfNeeded(currentGalleryIndex, 'mobile');
      else scrollToThumbnailIfNeeded(currentGalleryIndex, 'desktop');
    }

    // ---------- Smart scroll ----------
    function scrollToThumbnailIfNeeded(index, type = 'auto') {
      const isMobile = (type === 'mobile') || (type === 'auto' && window.innerWidth < 1024);
      const container = isMobile ? thumbsMobile : thumbsDesktop;
      if (!container) return;
      const thumbs = Array.from(container.children);
      const target = thumbs[index];
      if (!target) return;

      // For vertical container, use scrollTop/offsetTop; for horizontal - scrollLeft/offsetLeft
      const isHorizontal = isMobile;
      const visibleCount = calculateVisibleThumbnails(container, isMobile);
      const total = thumbs.length;

      // compute view start/end in content coordinates
      const viewStart = isHorizontal ? container.scrollLeft : container.scrollTop;
      const viewSize = isHorizontal ? container.clientWidth : container.clientHeight;
      const targetStart = isHorizontal ? target.offsetLeft : target.offsetTop;
      const targetSize = isHorizontal ? target.offsetWidth : target.offsetHeight;
      const targetEnd = targetStart + targetSize;

      // is fully visible?
      if (targetStart >= viewStart && targetEnd <= viewStart + viewSize) return;

      const maxScroll = (isHorizontal ? container.scrollWidth : container.scrollHeight) - viewSize;

      // if near start
      if (index <= Math.floor(visibleCount / 2)) {
        smoothScrollTo(container, 0, isHorizontal);
        return;
      }
      // if near end
      if (index >= total - Math.ceil(visibleCount / 2)) {
        smoothScrollTo(container, maxScroll, isHorizontal);
        return;
      }

      // center thumbnail
      const targetCenter = targetStart - (viewSize / 2) + (targetSize / 2);
      const dest = Math.max(0, Math.min(maxScroll, targetCenter));
      smoothScrollTo(container, dest, isHorizontal);
    }

    function smoothScrollTo(container, value, horizontal = true) {
      // Use native smooth behavior where supported
      if (horizontal) {
        container.scrollTo({ left: value, behavior: 'smooth' });
      } else {
        container.scrollTo({ top: value, behavior: 'smooth' });
      }
    }

    // ---------- Gallery image update ----------
    function updateGalleryImage() {
      const p = photos[currentGalleryIndex];
      if (!p) return;
      // preload to avoid flash
      const tmp = new Image();
      tmp.onload = () => {
        galleryImg.src = p.src;
        galleryImg.alt = p.alt || '';
        resetZoom(); // ensure consistent state
        if (galleryCounter) galleryCounter.textContent = `${currentGalleryIndex + 1} / ${photos.length}`;
      };
      tmp.onerror = () => {
        galleryImg.src = p.src;
        galleryImg.alt = p.alt || '';
        resetZoom();
        if (galleryCounter) galleryCounter.textContent = `${currentGalleryIndex + 1} / ${photos.length}`;
      };
      tmp.src = p.src;
    }

    // ---------- Zoom / Pan core ----------
    function applyTransform() {
      // transform: translate then scale (translate in px relative to element)
      galleryImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    }

    // compute max pan allowed based on natural size and container size
    function computePanLimits() {
      const rect = galleryImageContainer.getBoundingClientRect();
      // natural sizes (intrinsic)
      const naturalW = galleryImg.naturalWidth || galleryImg.width;
      const naturalH = galleryImg.naturalHeight || galleryImg.height;

      // scaled sizes
      const scaledW = naturalW * currentScale;
      const scaledH = naturalH * currentScale;

      // if image smaller than container -> no pan allowed
      const maxX = Math.max(0, (scaledW - rect.width) / 2);
      const maxY = Math.max(0, (scaledH - rect.height) / 2);

      return { maxX, maxY, containerRect: rect, scaledW, scaledH };
    }

    function clampTranslate() {
      const { maxX, maxY } = computePanLimits();
      translateX = Math.max(-maxX, Math.min(maxX, translateX));
      translateY = Math.max(-maxY, Math.min(maxY, translateY));
    }

    function zoomTo(scale, focusX = null, focusY = null) {
      // optional focusX/Y are client coords where we should keep point fixed (for wheel/mouse)
      const prevScale = currentScale;
      const newScale = Math.max(1, Math.min(MAX_ZOOM, scale));
      if (newScale === prevScale) return;

      // if focusing on a point, adjust translate so that that point stays under cursor
      if (focusX !== null && focusY !== null) {
        const rect = galleryImageContainer.getBoundingClientRect();
        // point relative to image center in container coordinates:
        const cx = focusX - rect.left - rect.width / 2;
        const cy = focusY - rect.top - rect.height / 2;
        // adjust translate proportionally to scale change
        translateX = (translateX) * (newScale / prevScale) + (cx) * (1 - newScale / prevScale);
        translateY = (translateY) * (newScale / prevScale) + (cy) * (1 - newScale / prevScale);
      } else {
        // scale around center: keep translate proportional
        translateX = translateX * (newScale / prevScale);
        translateY = translateY * (newScale / prevScale);
      }

      currentScale = newScale;
      isZoomed = currentScale > 1.01;
      clampTranslate();
      applyTransform();
      updateZoomIndicator();

      // desktop vs mobile behavior
      if (!isTouchDevice() && isZoomed) enableDesktopZoomMode();
      else disableDesktopZoomMode();

      updateInteractionTime();
    }

    function zoomIn() {
      zoomTo(Math.min(MAX_ZOOM, currentScale + ZOOM_STEP));
    }
    function zoomOut() {
      zoomTo(Math.max(1, currentScale - ZOOM_STEP));
    }

    function toggleZoom(clientX = null, clientY = null) {
      if (isZoomed) resetZoom();
      else {
        // center on click if coords provided
        const defaultScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, (MIN_ZOOM + MAX_ZOOM) / 2));
        if (clientX !== null && clientY !== null) zoomTo(defaultScale, clientX, clientY);
        else zoomTo(defaultScale);
      }
    }

    function resetZoom() {
      currentScale = 1;
      translateX = 0;
      translateY = 0;
      isZoomed = false;
      applyTransform();
      updateZoomIndicator();
      disableDesktopZoomMode();
      if (galleryResetZoom) galleryResetZoom.classList.add('hidden');
      clearTimeout(autoResetZoomTimer);
    }

    function updateZoomIndicator() {
      if (!galleryZoomIndicator) return;
      if (isZoomed) {
        galleryZoomIndicator.textContent = Math.round(currentScale * 100) + '%';
        galleryZoomIndicator.classList.remove('hidden');
        if (galleryResetZoom) galleryResetZoom.classList.remove('hidden');
      } else {
        galleryZoomIndicator.classList.add('hidden');
      }
    }

    // ---------- Desktop hover pan mode ----------
    let desktopMouseHandler = (e) => {
      if (!isZoomed || isTouchDevice()) return;
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => {
        rafPending = false;
        const rect = galleryImageContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const posX = mouseX / rect.width;
        const posY = mouseY / rect.height;

        const { maxX, maxY } = computePanLimits();

        translateX = maxX - posX * (maxX * 2);
        translateY = maxY - posY * (maxY * 2);

        clampTranslate();
        applyTransform();
      });
      updateInteractionTime();
    };

    function enableDesktopZoomMode() {
      if (!galleryImageContainer) return;
      galleryImageContainer.addEventListener('mousemove', desktopMouseHandler);
      galleryImageContainer.addEventListener('mouseleave', handleDesktopMouseLeave);
    }
    function disableDesktopZoomMode() {
      if (!galleryImageContainer) return;
      galleryImageContainer.removeEventListener('mousemove', desktopMouseHandler);
      galleryImageContainer.removeEventListener('mouseleave', handleDesktopMouseLeave);
    }
    function handleDesktopMouseLeave() {
      // reset to centered when leaving
      if (isZoomed && !isTouchDevice()) {
        resetZoom();
      }
    }

    // ---------- Drag (touch) ----------
    function startDrag(clientX, clientY) {
      isDragging = true;
      dragStartX = clientX - translateX;
      dragStartY = clientY - translateY;
      updateInteractionTime();
    }
    function moveDrag(clientX, clientY) {
      if (!isDragging || !isZoomed) return;
      const dx = clientX - dragStartX;
      const dy = clientY - dragStartY;
      translateX = dx;
      translateY = dy;
      clampTranslate();
      applyTransform();
      updateInteractionTime();
    }
    function stopDrag() {
      if (!isDragging) return;
      isDragging = false;
      updateInteractionTime();
      // restart auto-reset on mobile
      if (isTouchDevice() && isZoomed) {
        clearTimeout(autoResetZoomTimer);
        autoResetZoomTimer = setTimeout(() => {
          if (Date.now() - lastInteraction >= MOBILE_AUTO_RESET_DELAY) resetZoom();
        }, MOBILE_AUTO_RESET_DELAY);
      }
    }

    // ---------- Touch handlers ----------
    galleryImg.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        // single finger - potential drag when zoomed
        if (!isZoomed) return;
        const t = e.touches[0];
        startDrag(t.clientX, t.clientY);
      } else if (e.touches.length === 2) {
        // pinch start
        e.preventDefault();
        const d = getDistance(e.touches[0], e.touches[1]);
        pinchStartDistance = d;
        pinchStartScale = currentScale;
      }
    }, { passive: false });

    galleryImg.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1 && isDragging) {
        e.preventDefault();
        const t = e.touches[0];
        moveDrag(t.clientX, t.clientY);
      } else if (e.touches.length === 2) {
        e.preventDefault();
        const d = getDistance(e.touches[0], e.touches[1]);
        if (!pinchStartDistance) pinchStartDistance = d;
        const factor = d / pinchStartDistance;
        const newScale = Math.max(1, Math.min(MAX_ZOOM, pinchStartScale * factor));
        // scale around center between two touches
        const rect = galleryImageContainer.getBoundingClientRect();
        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        zoomTo(newScale, centerX, centerY);
      }
    }, { passive: false });

    galleryImg.addEventListener('touchend', (e) => {
      if (e.touches.length === 0) {
        stopDrag();
        pinchStartDistance = 0;
      }
    });

    function getDistance(a, b) {
      const dx = a.clientX - b.clientX;
      const dy = a.clientY - b.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // ---------- Mouse events ----------
    // click toggles zoom (use event coordinates to focus)
    galleryImg.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleZoom(e.clientX, e.clientY);
    });

    // wheel zoom (desktop), only when not touch device
    galleryImageContainer.addEventListener('wheel', (e) => {
      if (isTouchDevice()) return;
      if (e.ctrlKey) return; // let browser handle pinch-zoom when ctrl pressed
      e.preventDefault();
      const delta = e.deltaY;
      if (delta < 0) {
        // zoom in around pointer
        zoomTo(Math.min(MAX_ZOOM, currentScale + ZOOM_STEP), e.clientX, e.clientY);
      } else {
        zoomTo(Math.max(1, currentScale - ZOOM_STEP), e.clientX, e.clientY);
      }
    }, { passive: false });

    // pointer-based dragging (desktop dragging when zoomed)
    galleryImg.addEventListener('pointerdown', (e) => {
      // use pointer events to unify mouse/touch where supported
      if (e.pointerType === 'mouse' && e.button !== 0) return; // left click only
      if (!isZoomed) return;
      pointerId = e.pointerId;
      galleryImg.setPointerCapture(pointerId);
      startDrag(e.clientX, e.clientY);
    });
    galleryImg.addEventListener('pointermove', (e) => {
      if (pointerId !== e.pointerId) return;
      if (isDragging) moveDrag(e.clientX, e.clientY);
    });
    galleryImg.addEventListener('pointerup', (e) => {
      if (pointerId !== e.pointerId) return;
      galleryImg.releasePointerCapture(pointerId);
      pointerId = null;
      stopDrag();
    });
    galleryImg.addEventListener('pointercancel', () => {
      if (pointerId) {
        galleryImg.releasePointerCapture(pointerId);
        pointerId = null;
      }
      stopDrag();
    });

    // ---------- Keyboard ----------
    window.addEventListener('keydown', (e) => {
      if (!galleryModal.classList.contains('opacity-100')) return;
      if (e.key === 'Escape') {
        if (isZoomed) resetZoom();
        else closeGallery();
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        smartNavigate(-1);
      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        smartNavigate(1);
      } else if (e.key === '0') resetZoom();
      else if (e.key === '1') {
        zoomTo((MIN_ZOOM + MAX_ZOOM) / 2);
      } else if (e.key === '+' || e.key === '=') zoomIn();
      else if (e.key === '-' || e.key === '_') zoomOut();

      updateInteractionTime();
    });

    // ---------- Navigation (prev/next) ----------
    function smartNavigate(direction) {
      // direction: -1 prev, 1 next
      resetZoom();
      updateInteractionTime();
      const total = photos.length;
      if (total === 0) return;
      let newIndex = currentGalleryIndex + direction;
      if (newIndex < 0) newIndex = total - 1;
      if (newIndex >= total) newIndex = 0;
      currentGalleryIndex = newIndex;
      updateGalleryImage();
      updateThumbnailSelection();

      // scroll to new thumb
      scrollToThumbnailIfNeeded(newIndex, window.innerWidth < 1024 ? 'mobile' : 'desktop');
    }

    // ---------- Open / Close gallery ----------
    function openAt(index) {
      if (index < 0 || index >= photos.length) index = 0;
      currentGalleryIndex = index;
      resetZoom();
      createThumbnails();
      updateGalleryImage();
      galleryModal.classList.remove('hidden', 'pointer-events-none');
      // small timeout to allow transition to animate
      setTimeout(() => {
        galleryModal.classList.add('opacity-100', 'pointer-events-auto');
        updateInteractionTime();
      }, 10);
    }

    function closeGallery() {
      resetZoom();
      galleryModal.classList.remove('opacity-100', 'pointer-events-auto');
      setTimeout(() => {
        galleryModal.classList.add('hidden', 'pointer-events-none');
      }, 300);
      clearTimeout(autoResetZoomTimer);
    }

    // ---------- Small helpers ----------
    function updateThumbnailSliderHeight() {
      // keep your previous behavior — adapt container heights
      const track = document.querySelector('.slider-track');
      const container = document.querySelector(".slider-thumbnails-container > .relative");
      if (!track || !container) return;
      if (window.innerWidth < 1024) {
        // reset mobile
        track.style.height = '';
        track.style.maxHeight = '';
        track.style.width = '';
        track.style.minWidth = '';
        track.style.maxWidth = '';
        container.style.height = '';
        container.style.maxHeight = '';
        container.style.width = '';
        container.style.minWidth = '';
        container.style.maxWidth = '';
        return;
      }
      const mainImageEl = document.querySelector('#mainImageContainer > img');
      if (!mainImageEl) return;
      const imageHeight = mainImageEl.getBoundingClientRect().height;
      if (imageHeight <= 0) return;
      const btnHeight = 20;
      const gap = 16;
      const desiredTrackHeight = imageHeight - btnHeight * 2 - gap;
      const finalTrackHeight = desiredTrackHeight > 100 ? desiredTrackHeight : 400;
      container.style.height = imageHeight + 'px';
      container.style.maxHeight = imageHeight + 'px';
      container.style.width = '80px';
      container.style.minWidth = '80px';
      container.style.maxWidth = '80px';
    }

    function refreshSlider() {
      updateThumbnailSliderHeight();
    }

    // ---------- Events wiring ----------
    galleryClose?.addEventListener('click', closeGallery);
    galleryModal?.addEventListener('click', (e) => {
      if (e.target === galleryModal) closeGallery();
    });

    galleryPrev?.addEventListener('click', () => smartNavigate(-1));
    galleryNext?.addEventListener('click', () => smartNavigate(1));
    if (galleryResetZoom) galleryResetZoom.addEventListener('click', resetZoom);

    window.addEventListener('resize', () => {
      // on resize keep UX predictable: recompute limits and clamp
      clampTranslate();
      refreshSlider();
      if (isZoomed && !isTouchDevice()) disableDesktopZoomMode();
    });
    window.addEventListener('load', refreshSlider);
    mainImage?.addEventListener('load', refreshSlider);

    // ---------- Initial hookup for thumbnail-click that updates main image in product view ----------
    function changeMainImage(thumb) {
      const bigImage = thumb.dataset.bigimage;
      const alt = thumb.alt;
      const index = parseInt(thumb.dataset.index, 10);
      if (!mainImage || !bigImage || isNaN(index)) return;
      // clear others
      document.querySelectorAll('.slider-track img').forEach(img => img.style.borderColor = '');
      thumb.style.setProperty('border-color', '#2563eb', 'important');
      currentMainIndex = index;
      const tmp = new Image();
      tmp.onload = () => {
        mainImage.src = bigImage;
        mainImage.alt = alt || '';
        requestAnimationFrame(refreshSlider);
      };
      tmp.onerror = () => {
        mainImage.src = bigImage;
        mainImage.alt = alt || '';
        requestAnimationFrame(refreshSlider);
      };
      tmp.src = bigImage;
    }

    const firstThumb = document.querySelector('.slider-track img');
    if (firstThumb) {
      currentMainIndex = parseInt(firstThumb.dataset.index, 10) || 0;
      changeMainImage(firstThumb);
    }
    document.querySelectorAll('.slider-track img').forEach(img => img.addEventListener('click', () => changeMainImage(img)));

    // ---------- Accessibility / keyboard focus ----------
    // (kept minimal — ESC handled above)

    // ---------- Init ----------
    // set initial cursors & hooks
    galleryImg.style.transition = 'transform 0.25s ease';
    setTimeout(() => {
      // ensure DOM ready thumbnails
      createThumbnails();
      setCursorState();
    }, 50);

    function setCursorState() {
      if (isZoomed) {
        if (!isTouchDevice()) galleryImg.classList.remove('cursor-zoom-in'), galleryImg.classList.add('cursor-zoom-out');
        else galleryImg.classList.remove('cursor-zoom-in'), galleryImg.classList.add('cursor-grab');
      } else {
        galleryImg.classList.remove('cursor-grab', 'cursor-zoom-out');
        galleryImg.classList.add('cursor-zoom-in');
      }
    }

    // expose small helpers to console for debug (optional)
    window.__gallery = {
      openAt, closeGallery, smartNavigate, zoomIn, zoomOut, resetZoom
    };
  });
</script>

